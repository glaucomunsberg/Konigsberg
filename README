################################################################################
#                       Konigsberg - Trabalho de EDII
################################################################################
#
# 1.Introduçao
# 2.Como foi programado
# 3.Comandos
# 4.Como executar
# 5.Resultados obtidos
# 6.Conclusão
#
# @autor   Glauco Roberto Munsberg dos Santos
# @github  git@github.com:glaucomunsberg/Konigsberg.git
# @version 0.4.5
#
################################################################################
# 1.Introduçao
################################################################################
#
#   Projeto Konigsberg se propõem a realizar o trabalho de EDII, proposto pelo 
#   professor Ricardo Matsumura Araújo e que está espeficido através dos links:
#   * Primeira parte do Trabalho:
#       http://avainstitucional.ufpel.edu.br/mod/assignment/view.php?id=25409
#   * Segunda parte do Trabalho:
#       http://avainstitucional.ufpel.edu.br/mod/assignment/view.php?id=25879
#       sendo esse segundo trabalho realizado em conjunto com também acadêmico
#       da ciência da computação André Peil.
#
#   O repositório e o projeto recebe o nome 'Königsberg' em referencia ao 
#   problema histórico relacionado aos grafos. O trabalho foi versionado no 
#   GitHub como apoio a programação, para o maior detalhamento das versões 
#   consulte o arquivo "version.txt". 
#
#   O trabalho foi programado e testado em um computador:
#    * Pentium Dual Core 2.2GHz
#    * 2,5GB Memória RAM DDR2
#    * Ubuntu 12.04 32-bits, área de troca de 1Gb para auxílio, com Java7
#      e demais configurações padrões.
#
#   1.1 Resultado Obtido
#       Usando uma JMV de no máximo 2,3Gb os resultados* obtidos foram:
#
#   1.1.1 Grafos
#       Numero de Arestas: XX
#       Tamanho da Vertices: XX
#       Tempo de execução : XX,Xs
#
#   1.1.2 Visualização de Grafos
#       Numero de caract.: 5mil
#       Tempo de execução: 57,7s
#
#   *Sem estouro de memória e inferior a XXsegundos
#
################################################################################
# 2.Como foi programado
################################################################################
#
#   O projeto Konigsberg dividido em duas partes, sendo a primeira programada
#   por Glauco Roberto Munsberg dos Santos e a segunda parte programada por este
#   e André Peil sendo o desenvolvimento ocorrido do periodo entre 3 de Julho de
#   2012 até XX de XX de 2012. Para isso foi usado a linguagem de programação 
#   Java dando continuidade aos conceitos obtido através da, também disciplica
#   na Ciência da Computação, Programação Orientada à Objetos. 
#
#   PRIMEIRA PARTE:
#   SEGUNDA PARTE:
#
#   A documentação do código está dividida em duas parte: A primeira que se 
#   refere o comportamente do programa e se encontra neste arquivo, a segunda se
#   encontra diretamente nos arquivos *.java referente como é executado os seus 
#   métodos e comportamento interno, bem como o retorno e seu tipo
#
################################################################################
# 3.Comandos
################################################################################
#
#   Os comandos  funcionando sempre em bloco tendo primeiro comando indicando
#   qual grupo pertence os comandos seguintes a ele, até que outro grupo seja
#   indicado. Para finalizar a lista de comando basta inserir um arroba.
#   Veja como seria no exemplo1:
#
#   -exemplo1----------------------------
#   |	<TIPO_1>			|
#   |	<COMANDO_DO_TIPO1>		|
#   |	<COMANDO_DO_TIPO1>		|
#   |	<TIPO_2>			|
#   |	<COMANDO_DO_TIPO2>		|
#   |	<TIPO_1>			|
#   |	<COMANDO_DO_TIPO1>		|
#   |     @				|
#   -------------------------------------
#   -console_return----------------------
#   |					|
#   -------------------------------------
#   Todo grupo tem a característica de começar com "*", assim quando há a
#   presença de um comando, que começa com asterisco, o programa entende que
#   os(s) próximo(s) comando(s) pertence #a daquele grupo.
#   Vejamos abaixo a lista de todos os comandos e o índice de sua documentação.
#
#   Os comandos não são case-sensitive enquanto sua sua sintaxe, porém seus
#   parâmetros não obedece a isso. Porém é necessário que cada grupo contenha 
#   pelo menos UM comando. Não podendo assim colocar dois grupos de comandos 
#   sem um comando do primeiro grupo esteja entre eles.
#   Veja exemplo do que NÂO se pode fazer:
#
#     -arquivo_nao_executa1.txt----------
#     |	<TIPO1>				|
#     |	<COMANDO_TIPO_2>		|
#     |	@				|
#     -----------------------------------
#     -console_return--------------------
#     |					|
#     -----------------------------------
#
#   Leia abaixo mais sobre os comandos, ou pegue os arquivo dos exemplos no 
#   no diretório "exemplosDeComandos".
#
#   Veja abaixo a lista de comandos aceitos pelo programa:
#
#     -Lista_de_Comandos--------------------------
#     |COMANDO				| Indice |
#     | *vertices			|  3.2	 |
#     | <ID> "<NOME>"			|  3.2.1 |
#     | *Arcs				|  3.3	 |
#     | *Edges				|  3.3	 |
#     | <ID1> <ID2> <PESO>		|  3.3.1 |
#     | *Queries			|  3.4	 |
#     | get <ID>			|  3.4.1 |
#     | delete <ID>			|  3.4.2 |
#     | vizinhos <ID>			|  3.4.3 |
#     | conexao <ID1> <ID2>		|  3.4.4 |
#     | ordemtop			|  3.4.5 |
#     | arvoreminima			|  3.4.6 |
#     | menorcaminho			|  3.4.7 |
#     | @				|  3.5	 | 
#     --------------------------------------------
#
#   Descrição de funcionalidade de cada comando:
#
#   3.1 Grupos de Comandos
#      Os comandos são divididos em três grupos definidos segundo a utilidade 
#      no sistema. Sendo eles:
#      "*vértices" (3.2) agrupa dentro dele apenas um comando, de criaçao de
#      vértices no grafo.
#
#      "*Arcs" e "*Edges" (3.3) são comandos de criação de arestas no grafo.
#      Abriga-se nesse grupo também apenas um tipo comando.
#
#      "*Queries" (3.4) contém comandos de retorno do grafo, por exemplo o de
#      retornar se existe ou não uma aresta.
#      
#   3.2 *vertices
#      O comando "*vértice" informa ao programa que existirá um bloco de 
#      comandos após ele, esse bloco contém a inserção de um ou mais vértices 
#      no grafo. O comando não é case-sensitive permitindo ser digitado em 
#      caixa-alta também.
#
#         3.2.1 <ID> "<NOME>"
#         O comando de inserção de vértice deve estar dentro de um bloco do 
#         grupo de vértices. O comando é composto por duas partes:#         
#          <ID>     int    - id que terá o vértice podendo assumir todos os
#            entre  -2147483647 e 2147483647.
#          "<NOME>" string - nome que terá o vértice
#
#         A primeira parte referencia ao ID do vértice e deve ser um integer, 
#         a segunda é o nome do vértice e o nome é delimitado com aspas no 
#         início e no final.
#
#         Veja o exemplo a abaixo:
#           -arquivo_add_vertice.txt-------------
#           |	*vertices			|
#           |	1 "vertice 1"			|
#           |	3 "vertice 3"			|
#           |	2 "vertice 2"			|
#           |	@				|
#           -------------------------------------
#           -console_return----------------------
#           |					|
#           -------------------------------------
#         Obs.: Caso seja inserido um vértice com um ID já existente, este será 
#         ignorado a adição deste.
#
#   3.3 *Arcs e *Edges
#      Ambos comando "*arcs" e "*edges" informam ao programa que existirá um 
#      bloco de comandos após ele, esse bloco contém a inserção de uma ou mais 
#      arestas no grafo.
#
#      O comando não é case-sensitive permitindo ser digitado em caixa-alta 
#      também. Lembre-se que o programa lerá apenas uma vez o tipo de aresta, 
#      se a primeira aresta for inserida como do grupo *arcs, mesmo que use 
#      *edges respeitará ao primeiro tipo. Caso seja inserido o tipo *edges na 
#      primeira vez, será sempre *edges mesmo com inserção do tipo *arcs.
#
#      Veja a diferença entre ambos:
#      *arcs - Comando que insere arestas direcionadas, ou seja, para toda
#       aresta X com vértice origem A e vértice destinho B, existe uma aresta Y 
#       com vértice origem em B e vértice destino em A.
#      *edges- Comando que insere arestas não direcionadas, ou seja, para toda 
#       aresta X tem vertce origem em A e vértice destino B, porém não insere 
#       uma aresta com vértice origem B com  vértice destino em A.
#
#         3.3.1 <ID1> <ID2> <PESO>
#         O comando de inserção de aresta deve estar dentro de um bloco do 
#         grupo de arestas. Comando que é composto por três partes:
#          <ID1>  int - vértice de origem
#          <ID2>  int - vértice de destino
#          <PESO> int - peso da aresta
#         Veja abaixo um exemplo de como adicionar arestas direcionadas:  
#         
#           -arquivo_add_arestas_direc.txt-------
#           |	*vertices			|
#           |	1 "vertice 1"			|
#           |	3 "vertice 3"			|
#           |	2 "vertice 2"			|
#           |	*arcs				|
#           |	1 2 20				|
#           |	2 3 10				|
#           |	@				|
#           -------------------------------------
#           -console_return----------------------
#           |					|
#           -------------------------------------
#
#         Veja abaixo um exemplo de como adicionar arestas não direcionadas:
#
#           -arquivo_add_arestas_no_direc.txt----
#           |	*vertices			|
#           |	1 "vertice 1"			|
#           |	3 "vertice 3"			|
#           |	2 "vertice 2"			|
#           |	*edges				|
#           |	1 3 1				|
#           |	3 1 2				|
#           |	@				|
#           -------------------------------------
#           -console_return----------------------
#           |					|
#           -------------------------------------
#         Obs.: Caso não seja encontrado um ou ambos os vértices, o comando é 
#         descartado.
#
#   3.4 *Queries
#      O comando "*queries" informa ao programa que existirá um bloco de 
#      comandos após ele, esse bloco contém o retorno de informações do 
#      grafo. Os comandos aceitos nesse bloco estão descritos abaixo.
#      O comando não é case-senitive permitindo ser digitado em caixa-alta 
#      também.
#
#         3.4.1 get <ID>
#         O comando "get <ID>"retorna a string associada ao vértice de número 
#         ID, se este existir, ou indica a ocorrência de falha.
#         O comando é composto por duas partes:
#          get
#          <ID> - Índice do vértice
#
#         Veja um exemplo:
#         -arquivo_get_aresta.txt----------------
#         |	*vertices			|
#         |	1 "vertice 1"			|
#         |	*queries			|
#         |	get 1				|
#         |	get 2				|
#         |	@				|
#         ---------------------------------------
#         -console_return------------------------------------------------------
#         |	{"vértice":{"ID":1, "dado":"vértice 1", "resposta":"sucesso"}}|
#         |	{"vértice":{"ID":2, "dado":"", "resposta":"falha"}}           |
#         ---------------------------------------------------------------------
#
#         3.4.2 delete <ID>
#         O comando "get <ID>" remove o vértice ID do grafo, se este existir, 
#         ou retorna falha se ID não existir.
#         O comando é composto por duas partes:
#          delete
#          <ID> - Índice do vértice
#
#         Veja um exemplo:
#         -arquivo_delete_vertice.txt------------
#         |	*vertices			|
#         |	1 "vertice 1"			|
#         |	*queries			|
#         |	delete 1			|
#         |	delete 2			|
#         |	@				|
#         ---------------------------------------
#         -console_return------------------------------------------------
#         |	{"delete"{"ID":1,"resposta":"sucesso"}}			|
#         |	{"delete"{"ID":2,"resposta":"falha"}}			|
#          --------------------------------------------------------------
#         Obs.: Deletar um vértice implica em remove todo e qualquer aresta com 
#         origem ou destino no vertice tal.
#
#         3.4.3 vizinhos <ID>
#         O comando "get <ID>" retorna uma lista de vizinhos do vértice ID. No 
#         caso do grafo ser direcionado, os vizinhos são aqueles apontados pelo 
#         vértice ID. Retorna falha se o vértice ID não existir.
#         O comando é composto por duas partes:
#          vizinhos
#          <ID> - Índice do vértice
#
#         Veja um exemplo:
#         -arquivo_vizinhos_aresta.txt-----------
#         |	*vertices			|
#         |	1 "vertice 1"			|
#         |	2 "vertice 2"			|
#         |	*edges				|
#         |	1 2 1				|
#         |	*queries			|
#         |	vizinhos 1			|
#         |	vizinhos 2			|
#         |	@				|
#         ---------------------------------------
#         -console_return----------------------------------------------------
#         |	{"vizinhos":{"ID":1, "resposta":"sucesso", "vizinhos":[2]}} |
#         |	{"vizinhos":{"ID":2, "resposta":"falha", "vizinhos":[]}}    |
#         -------------------------------------------------------------------
#
#         3.4.4 conexao <ID1> <ID2>
#         O comando "conexao <ID1> <ID2>" informa se existe uma conexão entre 
#         os vértices ID1 e ID2. Falha se ID1 ou ID2 não existirem.
#         O comando é composto por três partes:
#          conexao
#          <ID1> - Índice do vértice origem
#          <ID2> - Índice do vértice destino
#
#         Veja um exemplo:
#         -arquivo_conexao_aresta.txt------------
#         |	*vertices			|
#         |	1 "vertice 1"			|
#         |	2 "vertice 2"			|
#         |	*edges				|
#         |	1 2 1				|
#         |	*queries			|
#         |	conexao 1 2			|
#         |	conexao 2 1			|
#         |	@				|
#         ---------------------------------------
#         -console_return--------------------------------------------------------------
#         |	{"conexao":{"ID1":1, "ID2":2, "resposta":"sucesso", "conexao":"sim"}} |
#         |	{"conexao":{"ID1":2, "ID2":1, "resposta":"falha", "conexao":""}}      |
#         -----------------------------------------------------------------------------
#
#         3.4.5 ordemtop
#         [not implement yet]
#
#         3.4.6 arvoreminima
#         [not implement yet]
#
#         3.4.7 menorcaminho
#         [not implement yet]
#         
#   3.5 @
#      O comando "@" é a condição de parada da leitura de comandos e encerra a 
#      execução do programa. Caso haja algum comando após ele, serão 
#      desconsiderados.
#      Veja um exemplo a abaixo:
#
#      -arquivo_condicao_parada.txt-------
#      |	*vertices		|
#      |	1 "vertice 1"		|
#      |	@			|
#      |	*queries		|
#      |	remove 1		|
#      |	remove 2		|
#      |	@			|
#      ----------------------------------
#      -console_return-------------------
#      |				|
#      ----------------------------------
#
################################################################################
# 4.Como executar
################################################################################
#
#
#
#
################################################################################
# 5.Resultados obtidos
################################################################################
#
#
#
#
################################################################################
# 6.Conclusão
################################################################################
#
#
#
#
################################################################################
